# Manipulating data tables using base functions

```{r echo=FALSE}
source("libs/Common.R")
options(width = 80)
```


```{r echo = FALSE}
R_ver(c)
```


## The subset function

You can subset a dataframe object by criteria using the `subset` function.

```{r}
subset(mtcars, mpg > 25)
```

You can combine individual criterion using boolean operators when selecting by row.

```{r}
subset(mtcars, (mpg > 25) & (hp > 65)  )
```

You can also subset by column. To select columns, add the `select =` argument.

```{r}
subset(mtcars, (mpg > 25) & (hp > 65) , select = c(mpg, cyl, hp))
```

Note that the `subset` function can behave in unexpected ways. This is why its authors recommend against using subset in a script (see `?subset`). Instead, they advocate using indices shown next.

## Subset using indices

You've already learned how to identify elements in an atomic vector or a data frame in [Chapter 3](https://mgimond.github.io/ES218/data_objects.html#data-structures). For example, to extract the second and fourth element of the following vector,

```{r}
x <- c("a", "f", "a", "d", "a")
```

type,

```{r}
x[c(2, 4)]
```

To subset a dataframe by index, you need to define *both* dimension's index (separated by a comma). For example, to extract the second row an fourth column type:

```{r}
mtcars[2,4 ]
```
This returns the intersection of the row and column--a single cell. 

You can, of course, extract table blocks by using `c()` operators and/or the colon operator.

```{r}
mtcars[5:12, c("hp", "mpg", "am")]
```
Note that here, we chose to reference the columns by their names instead of their index number.


## Extracting using logical expression and indices

We can also extract cells based on conditions. For example, to extract all elements in `x` that are equal to `"a"`, type:

```{r}
x[ x == "a" ]
```


Let's breakdown the above expression. The output of the expression `x == "a"` is `TRUE FALSE TRUE FALSE TRUE`, a logical vector with the same number of elements as `x`. The logical elements are then passed to the indexing brackets where they act as a "mask" as shown in the following graphic.

![](img/logical_mask.png){width="318"}

The elements that make it through the *extraction mask* are then combined into a new vector element to **reveal** those elements satisfying the query.

The same idea applies to dataframes. For example, to extract all rows in `mtcars` where `mpg > 30` type:

```{r}
mtcars[ mtcars$mpg > 30, ]
```

Here, we are "masking" the rows that do not satisfy the criterion using the `TRUE`/`FALSE` logical outcomes from the conditional operation. Note that we have to add `mtcars$` to the expression since the variable `mpg` does not exist as a standalone object.

The expression can be made more complex. For example, to select all rows where `mpg` is greater than `30` and where `carb` is equal to `2`, and limiting the columns to `hp`, `mpg` and `disp`, type:

```{r}
mtcars[ (mtcars$mpg > 30) & (mtcars$carb == 2), c("hp", "mpg", "disp")]
```

## Replacing values using logical expressions

We can adopt the same masking properties of logical variables to **replace** values in a vector. For example, to replace all instances of `"a"` in vector `x` with the character `"z"`, we first *expose* the elements equal to `"a"`, then assign the new value to the exposed elements.

```{r}
x[ x == "a" ] <- "z"
x
```

You can think of the logical *mask* as a template applied to a road surface before spraying that template with a can of `"z"` spray. Only the exposed portion of the street surface will be sprayed with the `"z"` values.

![](img/logical_mask_replace.png){width="326"}


You can apply this technique to dataframes as well. For example, to replace all elements in `mpg` with `-1` if `mpg < 25`, type:

```{r attr.output='style="max-height: 100px;"'}
mtcars2 <- mtcars 
mtcars2[ mtcars2$mpg < 25, "mpg"]  <-  -1
mtcars2
```

Note that we had to specify the column, `mpg`,  into which we are replacing the values. Had we left the second index empty, we would have replaced values across *all* columns for records having an `mpg` value less than `30`.
