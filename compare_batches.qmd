---
output: html_document
editor_options: 
  chunk_output_type: console
---
# Comparing data distributions: The q-q plot

```{r echo=FALSE, message=FALSE}
source("libs/Common.R")
library(gridExtra)
```


```{r echo = FALSE}
pkg_ver(c("dplyr", "ggplot2","lattice"))
```



Let's begin by comparing singer heights between two voice part groups: bassists and tenors. We will work off of a subset of the `singer` dataset which can be found in the `lattice` package.

```{r message=FALSE}
library(dplyr)
library(ggplot2)

df  <- lattice::singer
df2 <- filter(df, voice.part == "Bass 2" | voice.part=="Tenor 1") %>% 
       mutate(voice.part = droplevels(voice.part))
```

Let's plot both datasets side-by-side. We will jitter the points about their category groups to expose overlapping points.

```{r fig.height=3, fig.width=4}
ggplot(df2, aes(y=height, x=voice.part, col=voice.part)) + 
            geom_jitter(position = position_jitter(width = .1, height=0))
```

Comparing two batches of values in their entirety might prove difficult, especially if their values do not appear to differ by a whole lot--at least not visually when presented as side-by-side jitter plots. For this reason, we might find it helpful to reduce the batches down to summary statistics such as the mean or median. Doing so allows for a more objective comparison between two batches. 

For example, let's compute the median values for both batches.

```{r}
df2 %>% group_by(voice.part) %>% summarise(median = median(height))
```

When characterizing the batches using their median values, we determine that the bassists tend to be slightly taller than the tenors.

This is one way to compare the batches. But is the median (or any measure of centrality) the only way to compare batches? Why not compare the top tenth percentile of values or the lower quartile of values? Will such a summary lead to a similar conclusion? We expand on this question next.

&nbsp;&nbsp;

## Boxplots

A boxplot gives us additional handles by which to compare batches of values.

```{r fig.height=3, fig.width=3}
ggplot(df2) + aes(x = voice.part, y = height) + geom_boxplot()
```

In addition to providing us with the median, it also allows us to compare the lower and upper quartiles. Here, the bassists are taller than the tenors by all three measures. But note that the difference in height values is not consistent. 

```{r}
df2 %>% group_by(voice.part) %>% 
  summarise(upper = quantile(height,0.75), 
            mid = quantile(height,0.5),
            lower = quantile(height,0.25))
```

We see that the singer heights differ by 3 inches when comparing the upper quartiles, and by 4 inches when comparing the medians and lower quartiles.  

When comparing the minimum values, (these values can be extracted from the lower ends of the whiskers), we see that the difference is just 2 inches. And, interestingly, the tallest bassist is taller than the tallest tenor! So the offset between singer heights when paired up by their ordered height values is not consistent in size and int direction.

As you can see from this example, there is more than one way to compare a batch of values and yet, we've limited our comparisons to just 5 values. So, how can we compare *all* values in both datasets? By comparing their quantile functions. 



## The empirical quantile-quantile (q-q) plot

An **empirical quantile-quantile** plot (or **q-q plot** for short) combines two separate quantile functions from different batches of values by pairing their quantile values with their common $f$-value.

![](img/QQ_plot.png)

In the above figure, batches `a` and `b` have the same number of observations. As such, they have the same f-values. If the number of values in both batches are equal, then the plotting process is straightforward: sort both batches (from smallest value to largest value), then pair up the sorted values and plot one batch vs. the other batch. 

If, on the other hand, the two batches differ in size (as is the case with our example where we have 21 tenors and 26 bassists), we won't be able to match sorted values. 

![](img/qq_plot_diff_lengths.png)

For example, in the above graph, you'll note that the Bass height value of `74` is associated with an $f$-value of `0.75`, however, there is no singer height value associated with an $f$-value of 0.75 in the `Tenor1` batch. 

To overcome the problem of batch size mismatch, we limit the number of points in the q-q plot to the number of values associated with the *smallest* sized batch (21 in our working example). This requires that we find matching singer height values to the set of $f$-values associated with a batch of 21 values. There are a few ways this can be accomplished in R. The easiest way is to make use of the built-in `qqplot` function.

`qqplot` is a base package that will generate a q-q plot using the base plotting environment. It requires that the two batches be loaded as separate vector objects. It also offers the option to output the q-q plot interpolated values as a **list**  by setting the parameter `plot.it = FALSE`. We then convert this list object to a dataframe using `as.data.frame`. 

```{r}
Tenor <- filter(df, voice.part == "Tenor 1") %>%  pull(height)
Bass  <- filter(df, voice.part == "Bass 2")  %>%  pull(height)

qq.out <- qqplot(x=Tenor, y=Bass, plot.it=FALSE)
qq.out <- as.data.frame(qq.out)
names(qq.out) <- c("Tenor", "Bass")
```

We can now generate the q-q plot using `ggplot`.

```{r fig.height=3, fig.width=3}
# Set the x and y limits
xylim <- range( c(qq.out$Tenor, qq.out$Bass) )

# Generate the QQ plot
ggplot(qq.out, aes( x= Tenor, y = Bass)) + 
               geom_point() + 
               geom_abline( intercept=0, slope=1) +
               coord_fixed(ratio = 1, xlim=xylim, ylim = xylim) 
```

Note that the `qqplot` function can also generate a base plot.

```{r fig.height=3, fig.width=3, echo=2:3}
OP <- par(mar=c(4,4,0,0))
qqplot(x=Tenor, y=Bass, asp=1)
abline( c(0,1))
par(OP)
```


## q-q plots vs. traditional scatter plots

It's important to note the difference between a quantile-quantile plot and a *traditional* [scatter plot](https://en.wikipedia.org/wiki/Scatter_plot) whereby the pairing of values between variables is explicitly defined  (for example average male and female income values paired by county). The singer data does not assume any pairing of observations (e.g. the height measurement for a singer in `Bass` is independent for that of a singer in `Tenor 2`).  This is made more evident with our working example which has unequal number of singers in both groups being compared. The pairing of values in a q-q plot is constructed from the *ordering* of values in each batch and nothing more.

## What can we learn from a q-q plot?


### Additive offset

A valuable by-product of an empirical q-q plot is the mathematical relationship between the batches of values. If the distributions are identical (i.e. all the points of a q-q plot fall on the 45&deg; line) then we could characterize the relationship as `batch1 = batch2`. 

If the points follow a pattern mimicking a line parallel to the 45&deg; line as in the following plot, then we say that there is an **additive shift** between `batch1` and `batch2`.

```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
library(tukeyedar)
set.seed(132)
set.seed(132)
batch1  <- sort(runif(50,10,20))
batch2  <- sort(batch1 + 2 + rnorm(length(batch1), 0,1))
s1 <- data.frame(batch1, batch2)

OP <- par(mfrow=c(1,2))
eda_qq(batch1, batch2, show.par = FALSE)
eda_dens(batch1, batch2, show.par = FALSE, bw=2)
par(OP)
```

An additive shift between batches results in an offset in density distributions with matching shape as shown in the the figure on the right.

The shift can usually be eyeballed from the plot. In this example, the shift is around 2 units or `batch2 =  batch1 + 2`. 

```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
OP <- par(mfrow=c(1,2))
eda_qq(batch1, batch2,fx = "x + 2"  ,show.par = FALSE, xlab = "batch1 + 2")
eda_dens(batch1, batch2,fx = "x + 2", show.par = FALSE, bw = 2)
par(OP)
```

Adding 2 to `batch1` lines the points up along the 45&deg; line. This translates to overlapping the density plots as shown on the right.

### Multiplicative offset

When the points follow a line at an angle to the 45&deg; line as in the following plot, then we say that there is a **multiplicative shift** between the batches.

```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
batch2  <- sort(batch1 * 2 + rnorm(length(batch1), 0,1))
OP <- par( mfrow=c(1,2) )
eda_qq(batch1, batch2 , show.par = FALSE)
eda_dens(batch1, batch2, show.par = FALSE, bw = 2)
par(OP)
```

A multiplicative shift between the batches results in a change in density shapes with one batch's density being shorter and wider (`batch2` in this example) than that of the other batch  (`batch1` in this example).

The multiplier can be a bit difficult to glean graphically so trial and error may be the best approach whereby we multiply one of the batches by a multiplier. For example, after some experimenting, we arrive at a multiplier of 2 which seems to do a good job in aligning the q-q points along the 45&deg; line. We thus define a relationship of `batch2 = batch1 * 2`.
 
```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
OP <- par(mfrow=c(1,2))
eda_qq(batch1, batch2, fx = "x * 2", show.par = FALSE, xlab = "batch1 * 2")
eda_dens(batch1, batch2, fx = "x * 2", show.par = FALSE, bw = 2)
par(OP)
```

Notice how applying a multiplier not only re-aligns the shape of both densities, but it also corrects the offset observed between both density distributions in the previous figure.

## Additive and multiplicative offsets

Sometimes, you might encounter a relationship that is both additive *and* multiplicative in which case you should first resolve the multiplicative part of the pattern until the points are close to being parallel with the 45&deg; line. Once the multiplicative component is taken care of, resolve the additive portion. 

```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
set.seed(132)
batch1  <- sort(runif(10,10,20))
batch2  <- sort(batch1 * 1.5 + 4 + rnorm(length(batch1), 0,1))

OP <- par(mfrow=c(1,2))
eda_qq(batch1, batch2 ,show.par = FALSE)
eda_dens(batch1, batch2, show.par = FALSE, bw = 3)
par(OP)
```        

The above dataset can be decomposed into its multiplicative component (multiply `batch1` by ~ 1.5),

```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
OP <- par(mfrow=c(1,2))
eda_qq(batch1, batch2 , fx = "x * 1.5", show.par = FALSE, xlab = "batch1 * 1.5")
eda_dens(batch1, batch2, fx = "x * 1.5", show.par = FALSE, bw =3 )
par(OP)

``` 

then by its additive component (we'll try and additive offset of 4):
 
```{r echo=FALSE, fig.width=7,fig.height=3.5, results = "hide"}
OP <- par(mfrow=c(1,2))
 eda_qq(batch1, batch2 , fx = "x * 1.5 + 4", show.par = FALSE, xlab = "batch1 * 1.5")
 eda_dens(batch1, batch2, fx = "x * 1.5 + 4", show.par = FALSE, bw =3 )
par(OP)

``` 

The relationship between both batches can thus be defined by `batch2 = batch1 * 1.5 + 4`.

### Is the relationship between tenor and bass additive or multiplicative?

Turning back to our voice part dataset, an additive shift is apparent, but a multiplicative shift not as much. To check, we'll add 2.5 to the `Bass` value.

```{r , fig.width=3, fig.height=3}
ggplot(qq.out, aes( x= Tenor + 2.5, y = Bass)) + 
             geom_point() + 
             geom_abline( intercept=0, slope=1) +
             coord_fixed(ratio = 1, xlim=c(65,80), ylim = c(65,80)) + xlab("Tenor + 2.5")
```

The bulk of the data appears to follow an additive shift except for one or two outliers at the upper end of the distribution. These outliers should not mislead us into assuming that a multiplicative offset is warranted here. 

## The Tukey mean-difference plot

Our eyes are better suited at judging deviations from a horizontal line than from a 45&deg; line.  All that is required is to subtract the y-value  (`Bass2`) from the x-value (`Tenor 2`) then compare the difference to the mean of the two values:

$$
Y = Bass- Tenor 
$$
$$
X = \frac{Bass + Tenor}{2}
$$

This forces the 45&deg; line in the previous q-q plots to a 0° slope. The final plot is a **Tukey mean-difference** plot or **m-d** for short.

### Generating a Tukey m-d plot using `ggplot`

We will continue with the `qq.out` dataset generated from the `qqplot` function.

```{r fig.height=3, fig.width=3}
md.y  <- (qq.out$Bass - qq.out$Tenor) 
md.x  <- (qq.out$Bass + qq.out$Tenor) * 0.5
df.md <- data.frame(md.x, md.y)

ggplot(df.md,  aes(x = md.x, y = md.y)) + geom_point() + geom_abline( slope=0 ) +
               xlab("Mean height (in)") + ylab("Difference in height (in)")
```

The units on both axes are in inches. It's clear from this plot that differences in heights are pretty much consistent across the quantiles with an additive shift of about 2.5 inches, except near the higher quantiles for a few lone points.

We can leverage this plot to help fine tune the additive offset by computing the median value from the height difference values.

```{r}
md.offset <- median(md.y)
md.offset
```

The value of `r md.offset` is in agreement with what we eyeballed earlier. 

## The `eda_qq` function

The `tukeyedar` package offers an improved version of the q-q plot function that you will be encouraged to use in this course. Some of its features that you may find helpful are highlighted next.

The function can take two separate vectors as input:

```{r  class.source="eda", fig.height=3, fig.width=2.5, results='hide'}
library(tukeyedar)
eda_qq(Tenor, Bass) 
```

It can also take a dataframe in long form as input. Note that the grouping variable assigned to the y-axis will be the first one listed in the group's levels. 

```{r}
levels(df2$voice.part)
```

Hence, `Bass 2` will be mapped to the y-axis.

```{r  class.source="eda", fig.height=3, fig.width=2.5, results='hide'}
eda_qq(df2, height, voice.part) 
```

The plot includes:

 +  Shaded boxes representing each batch’s interquartile range (mid 50% of values).
 +  Solid dashed lines inside the shaded boxes representing each batch’s medians.
 +  Lightly shaded dashed dots representing each batch’s 12.5th and 87.5th quantiles (i.e. they show the ends of the mid 80% of values).
 +  The power transformation applied to both batches shown in the upper right-hand corner of the plot. Power transformations will be covered later in this course.

To add the offset to the x-axis, pass `"x + 2.5"` to the `fx` argument.

```{r class.source="eda", fig.height=3, fig.width=2.5, results='hide'}
eda_qq(Tenor, Bass, fx = "x + 2.5")
```

If you want to apply an offset to the y-axis, use the `fy` argument. Don't forget to reference the `y` variable instead of the `x` variable.

```{r class.source="eda", fig.height=3, fig.width=2.5, results='hide'}
eda_qq(Tenor, Bass, fy = "y - 2.5")
```


You'll note that the function returns a "suggested" offset in the console. For example, the above code chunks return the following suggested offset:

```{r echo = FALSE}
eda_qq(Tenor, Bass, show.par = FALSE, plot=FALSE)
```

When applied to the x-axis variable, we get:

```{r class.source="eda", fig.height=3, fig.width=2.5, results='hide'}
eda_qq(Tenor, Bass, fx = " x * 0.8571 + 12.4286 ")
```

This seems to improve little over the simpler `x + 2` offset expression. Always seek a parsimonious relationship between batches when possible.

This function will also generate the Tukey mean-difference plot by setting `md` to `TRUE`.

```{r class.source="eda", fig.height=3, fig.width=2.5, results='hide'}
eda_qq(Tenor, Bass, md = TRUE)
```

Note that the offset arguments `fx` and `fy` can be applied to the mean-difference plot.

To learn more about the function, see [here](https://mgimond.github.io/tukeyedar/articles/qq.html).

