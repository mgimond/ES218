<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Week2: Data Object Type and Structure</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/font-awesome-4.5.0/css/font-awesome.min.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; } /* Keyword */
code > span.ch { color: #008080; } /* Char */
code > span.st { color: #008080; } /* String */
code > span.co { color: #008000; } /* Comment */
code > span.ot { color: #ff4000; } /* Other */
code > span.al { color: #ff0000; } /* Alert */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #008000; font-weight: bold; } /* Warning */
code > span.cn { } /* Constant */
code > span.sc { color: #008080; } /* SpecialChar */
code > span.vs { color: #008080; } /* VerbatimString */
code > span.ss { color: #008080; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #0000ff; } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ff4000; } /* Preprocessor */
code > span.do { color: #008000; } /* Documentation */
code > span.an { color: #008000; } /* Annotation */
code > span.cv { color: #008000; } /* CommentVar */
code > span.at { } /* Attribute */
code > span.in { color: #008000; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="libs\style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}

.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data Manipulation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 02</li>
    <li>
      <a href="Week02a.html">Data types</a>
    </li>
    <li>
      <a href="Week02b.html">Reading and writing data files</a>
    </li>
    <li>
      <a href="Week02c.html">Working with date objects</a>
    </li>
    <li>
      <a href="Week02d.html">Exploring and cleaning dataframes using base functions</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 03</li>
    <li>
      <a href="Week03a.html">Manipulating dataframes with dplyr</a>
    </li>
    <li>
      <a href="Week03b.html">Tidying/reshaping tables using tidyr</a>
    </li>
    <li>
      <a href="Week03ab_examples.html">Example of data manipulation workflows</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 04</li>
    <li>
      <a href="Week03c.html">Joining data tables</a>
    </li>
    <li>
      <a href="Week03d.html">Working with string objects</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Plots
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 05</li>
    <li>
      <a href="Week04a.html">The base plotting environment</a>
    </li>
    <li>
      <a href="Week04b.html">The lattice plotting environment</a>
    </li>
    <li>
      <a href="Week04c.html">The ggplot plotting environment</a>
    </li>
    <li>
      <a href="Week04d.html">Manipulating colors in R</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Univariate
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 06</li>
    <li>
      <a href="Week05a.html">Visualizing univariate data</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 07</li>
    <li>
      <a href="Week05b.html">Comparing univariate data distributions</a>
    </li>
    <li>
      <a href="Week06a.html">Theoretical Q-Q plot</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 08</li>
    <li>
      <a href="Week07a.html">Fits and residuals</a>
    </li>
    <li>
      <a href="Week07b.html">Spread-location plot</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 09</li>
    <li>
      <a href="Week08a.html">Re-expressing data</a>
    </li>
    <li>
      <a href="Week08b.html">Letter value summaries</a>
    </li>
    <li>
      <a href="Week08c.html">The Two R’s of EDA</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Bivariate
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 10</li>
    <li>
      <a href="Week09a.html">Bivariate analysis</a>
    </li>
    <li>
      <a href="Week09b.html">Resistant lines</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 11</li>
    <li>
      <a href="Week10a.html">The third R of EDA: Residuals</a>
    </li>
    <li>
      <a href="Week10b.html">Detecting discontinuities in the data</a>
    </li>
    <li>
      <a href="http://mgimond.github.io/Stats-in-R/regression.html">Details of the OLS regression method (optional reading)</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Two-way tables
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 12</li>
    <li>
      <a href="Week11a.html">Median polish/Mean polish</a>
    </li>
    <li>
      <a href="http://mgimond.github.io/Stats-in-R/ANOVA.html">Details of an ANOVA (optional reading)</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Misc
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 13</li>
    <li>
      <a href="Week12a.html">Creating maps in R</a>
    </li>
    <li class="dropdown-header">Connecting to relational databases</li>
  </ul>
</li>
<li>
  <a href="Data.html">Datasets</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans%7CSource+Code+Pro" rel="stylesheet">

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Week2: Data Object Type and Structure</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#core-data-types">Core data types</a><ul>
<li><a href="#numeric">Numeric</a></li>
<li><a href="#character">Character</a></li>
<li><a href="#logical">Logical</a></li>
</ul></li>
<li><a href="#derived-data-types">Derived data types</a><ul>
<li><a href="#factor">Factor</a><ul>
<li><a href="#rearranging-level-order">Rearranging level order</a></li>
<li><a href="#subsetting-table-by-level-and-re-leveling">Subsetting table by level and <em>re-leveling</em></a></li>
</ul></li>
<li><a href="#date">Date</a></li>
<li><a href="#na-and-null">NA and NULL</a></li>
</ul></li>
<li><a href="#data-structures">Data structures</a><ul>
<li><a href="#atomic-vectors">(Atomic) Vectors</a></li>
<li><a href="#matrices-and-arrays">Matrices and arrays</a></li>
<li><a href="#data-frames">Data frames</a></li>
<li><a href="#lists">Lists</a></li>
</ul></li>
<li><a href="#coercing-data-from-one-type-to-another">Coercing data from one type to another</a><ul>
<li><a href="#factors_xtr">A word of caution when converting from factors</a></li>
</ul></li>
</ul>
</div>

<p>R objects can store values as different <em>core</em> data types (referred to as <strong>modes</strong> in R jargon); these include <strong>numeric</strong> (both integer and double), <strong>character</strong> and <strong>logical</strong>.</p>
<p>R expands these modes into <em>derived</em> data types such as <strong>dates</strong> and <strong>factors</strong> by assigning <em>attribute</em> information to these objects.</p>
<div id="core-data-types" class="section level1">
<h1>Core data types</h1>
<p>These data types, or <strong>modes</strong>, define how the values are stored in the computer. You can get an object’s mode using the <code>typeof()</code> function. Note that R also has a built-in <code>mode()</code> function that will serve the same purpose with the one exception in that it will not distinguish integers from doubles.</p>
<div id="numeric" class="section level2">
<h2>Numeric</h2>
<p>The <strong>numeric</strong> data type is probably the simplest. It consists of numbers such as integers (e.g. <code>1 ,-3 ,33 ,0</code>) or doubles (e.g. <code>0.3, 12.4, -0.04, 1.0</code>). For example, to create a numeric (double) vector we can type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">1.0</span>, <span class="op">-</span><span class="fl">3.4</span>, <span class="dv">2</span>, <span class="fl">140.1</span>)
<span class="kw">mode</span>(x)</code></pre></div>
<pre><code>[1] &quot;numeric&quot;</code></pre>
<p>To assess if the number is stored as an <em>integer</em> or a <em>double</em> use the <code>typeof()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(x)</code></pre></div>
<pre><code>[1] &quot;double&quot;</code></pre>
<p>Note that removing the fraction part of a number when creating a numeric object does not necessarily create an integer. For example, creating what seems to be an integer object returns <em>double</em> when queried by <code>typeof()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">4</span>
<span class="kw">typeof</span>(x)</code></pre></div>
<pre><code>[1] &quot;double&quot;</code></pre>
<p>To force R to recognize a value as an integer add an upper case <code>L</code> to the number.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span>4L
<span class="kw">typeof</span>(x)</code></pre></div>
<pre><code>[1] &quot;integer&quot;</code></pre>
</div>
<div id="character" class="section level2">
<h2>Character</h2>
<p>The <strong>character</strong> data type consists of letters or words such as <code>&quot;a&quot;, &quot;f&quot;, &quot;project&quot;, &quot;house value&quot;</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;f&quot;</span>, <span class="st">&quot;project&quot;</span>, <span class="st">&quot;house value&quot;</span>)
<span class="kw">typeof</span>(x)</code></pre></div>
<pre><code>[1] &quot;character&quot;</code></pre>
<p>Characters can also consist of numbers represented as characters. The distinction between a character representation of a number and a numeric one is important. For example, if we have two numeric vectors <code>x</code> and <code>y</code> such as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="dv">3</span>
y &lt;-<span class="st"> </span><span class="fl">5.3</span></code></pre></div>
<p>and we choose to sum the two variables, we get:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x <span class="op">+</span><span class="st"> </span>y</code></pre></div>
<pre><code>[1] 8.3</code></pre>
<p>If we repeat these steps but instead choose to represent the numbers <code>3</code> and <code>5.3</code> as characters we get the following error message:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> &quot;3&quot;</span>
y &lt;-<span class="st"> &quot;5.3&quot;</span>
x <span class="op">+</span><span class="st"> </span>y</code></pre></div>
<pre><code>Error in x + y: non-numeric argument to binary operator</code></pre>
<p>Note the use of quotes to force numbers to character mode.</p>
</div>
<div id="logical" class="section level2">
<h2>Logical</h2>
<p><strong>Logical</strong> values can take on one of two values: <code>TRUE</code> or <code>FALSE</code>. These can also be represented as <code>1</code> or <code>0</code>. For example, to create a logical vector of 4 elements, you can type</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>, <span class="ot">FALSE</span>, <span class="ot">TRUE</span>)</code></pre></div>
<p>or</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">as.logical</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>))</code></pre></div>
<p>Note that in both cases, <code>typeof(x)</code> returns logical. Also note that the <code>1</code>’s and <code>0</code>’s in the last example are converted to <code>TRUE</code>’s and <code>FALSE</code>’s internally.</p>
</div>
</div>
<div id="derived-data-types" class="section level1">
<h1>Derived data types</h1>
<p>These data types are stored as either numeric, character or logical but have additional <em>attribute</em> information that allow these objects to be treated in special ways by certain functions in R. These attributes define an object’s <strong>class</strong> and can be extracted from that object via the <code>class()</code> function.</p>
<div id="factor" class="section level2">
<h2>Factor</h2>
<p><strong>Factors</strong> are normally used to group variables into a fixed number of unique categories or <strong>levels</strong>. For example, a dataset may be grouped by gender or month of the year. Such data are usually loaded into R as a numeric or character data type requiring that they be converted to a factor using the <code>as.factor()</code> function.</p>
<p>In the following chunk of code, we create a factor from a character object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a      &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;M&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;U&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;M&quot;</span>, <span class="st">&quot;F&quot;</span>, <span class="st">&quot;U&quot;</span>)
a.fact &lt;-<span class="st"> </span><span class="kw">as.factor</span>(a)</code></pre></div>
<p>To confirm that <code>a.fact</code> is indeed a factor, we call the <code>class</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(a.fact)</code></pre></div>
<pre><code>[1] &quot;factor&quot;</code></pre>
<p>Interestingly, if you look at <code>a.fact</code>’s mode, you’ll note that it’s stored as an integer even though values are character.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(a.fact)</code></pre></div>
<pre><code>[1] &quot;integer&quot;</code></pre>
<p>This is because a factor uses integers to point to one of the vectors’ unique values stored in the vector’s attribute header (more details are provided <a href="#factors_xtr">later</a> in this chapter).</p>
<p>The unique values associated with <code>a.fact</code> can be extracted using the <code>levels</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(a.fact)</code></pre></div>
<pre><code>[1] &quot;F&quot; &quot;M&quot; &quot;U&quot;</code></pre>
<p>To appreciate the benefits of a factor we’ll first create a dataframe (dataframes are data tables whose structure will be covered later in this tutorial). One column will be assigned the <code>a.fact</code> factor and another will be assigned some random numeric values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x      &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">166</span>, <span class="dv">47</span>, <span class="dv">61</span>, <span class="dv">148</span>, <span class="dv">62</span>, <span class="dv">123</span>, <span class="dv">232</span>, <span class="dv">98</span>, <span class="dv">93</span>, <span class="dv">110</span>)
dat    &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">x =</span> x, <span class="dt">gender =</span> a.fact)
dat</code></pre></div>
<pre><code>     x gender
1  166      M
2   47      F
3   61      F
4  148      U
5   62      F
6  123      M
7  232      M
8   98      M
9   93      F
10 110      U</code></pre>
<p>The <code>gender</code> column is now a factor with three levels: <code>F</code>, <code>M</code> and <code>U</code>. We can use the <code>str()</code> function to view the dataframe’s structure as well as its columns classes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(dat)</code></pre></div>
<pre><code>&#39;data.frame&#39;:   10 obs. of  2 variables:
 $ x     : num  166 47 61 148 62 123 232 98 93 110
 $ gender: Factor w/ 3 levels &quot;F&quot;,&quot;M&quot;,&quot;U&quot;: 2 1 1 3 1 2 2 2 1 3</code></pre>
<p>Many functions recognize factor data types and will allow you to split the output into groups defined by the factor’s unique levels. For example, to create three boxplots of the value <code>x</code>, one for each gender group <code>F</code>, <code>M</code> and <code>U</code>, type the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">boxplot</span>(x <span class="op">~</span><span class="st"> </span>gender, dat, <span class="dt">horizontal =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="Week02a_files/figure-html/unnamed-chunk-18-1.png" width="384" /></p>
<p>The tilde <code>~</code> operator is used in the plot function to split (or <em>condition</em>) the data into separate plots based on the factor <code>gender</code>.</p>
<div id="rearranging-level-order" class="section level3">
<h3>Rearranging level order</h3>
<p>A factor will define a hierarchy for its levels. When we invoked the <code>levels</code> function in the last example, you may have noted that the levels output were ordered <code>F</code>, <code>M</code> and<code>U</code>–this is the level hierarchy defined for <code>gender</code> (i.e. <code>F</code>&gt;<code>M</code>&gt;<code>U</code> ). This means that regardless of the order in which the factors appear in a table, anytime a plot or operation is conditioned by the factor the grouped elements will appear in the order defined by the levels’ hierarchy. When we created the boxplot from our <code>dat</code> object, the plotting function ordered the boxplot (bottom to top) following <code>gender</code>’s level hierarchy (i.e. <code>F</code> first, then <code>M</code>, then <code>U</code>).</p>
<p>If we wanted the boxplots to be plotted in a different order (i.e. <code>U</code> first followed by <code>F</code> then <code>M</code>) we would need to modify the <code>gender</code> column by recreating the factor object as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat<span class="op">$</span>gender &lt;-<span class="st"> </span><span class="kw">factor</span>(dat<span class="op">$</span>gender, <span class="dt">levels=</span><span class="kw">c</span>(<span class="st">&quot;U&quot;</span>,<span class="st">&quot;F&quot;</span>,<span class="st">&quot;M&quot;</span>))
<span class="kw">str</span>(dat)</code></pre></div>
<pre><code>&#39;data.frame&#39;:   10 obs. of  2 variables:
 $ x     : num  166 47 61 148 62 123 232 98 93 110
 $ gender: Factor w/ 3 levels &quot;U&quot;,&quot;F&quot;,&quot;M&quot;: 3 2 2 1 2 3 3 3 2 1</code></pre>
<p>The <code>factor</code> function is given the original factor values (<code>dat$gender</code>) but is also given the levels in the new order in which they are to appear(<code>levels=c(&quot;U&quot;,&quot;F&quot;,&quot;M&quot;)</code>). Now, if we recreate the boxplot, the plot order (plotted from bottom to top) will reflect the new level hierarchy.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">boxplot</span>(x <span class="op">~</span><span class="st"> </span>gender, dat, <span class="dt">horizontal =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="Week02a_files/figure-html/unnamed-chunk-20-1.png" width="384" /></p>
</div>
<div id="subsetting-table-by-level-and-re-leveling" class="section level3">
<h3>Subsetting table by level and <em>re-leveling</em></h3>
<p>In this example, we can subset the table by level using the subset function. For example, to subset the values associated with <code>F</code> and <code>M</code>, type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat.f &lt;-<span class="st"> </span><span class="kw">subset</span>(dat, gender <span class="op">==</span><span class="st"> &quot;F&quot;</span> <span class="op">|</span><span class="st"> </span>gender <span class="op">==</span><span class="st"> &quot;M&quot;</span>)
dat.f</code></pre></div>
<pre><code>    x gender
1 166      M
2  47      F
3  61      F
5  62      F
6 123      M
7 232      M
8  98      M
9  93      F</code></pre>
<p>The double equality sign <code>==</code> differs from the single equality sign <code>=</code> in that the former asses a condition: it checks if the variable to the left of <code>==</code> equals the variable to the right.</p>
<p>However, if you display the levels associated with this new dataframe, you’ll see that level <code>U</code> is still listed even though it no longer appears in the <code>gender</code> column.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(dat.f<span class="op">$</span>gender)</code></pre></div>
<pre><code>[1] &quot;U&quot; &quot;F&quot; &quot;M&quot;</code></pre>
<p>This can be a nuisance when plotting the data subset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">boxplot</span>(x <span class="op">~</span><span class="st"> </span>gender, dat.f, <span class="dt">horizontal =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="Week02a_files/figure-html/unnamed-chunk-23-1.png" width="384" /></p>
<p>Even though no records are available for <code>U</code>, the plot function allocates a slot for that level. To resolve this, we can use the <code>droplevels</code> function to remove all unused levels.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat.f<span class="op">$</span>gender &lt;-<span class="st"> </span><span class="kw">droplevels</span>(dat.f<span class="op">$</span>gender)
<span class="kw">levels</span>(dat.f<span class="op">$</span>gender)</code></pre></div>
<pre><code>[1] &quot;F&quot; &quot;M&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">boxplot</span>(x <span class="op">~</span><span class="st"> </span>gender, dat.f, <span class="dt">horizontal =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="Week02a_files/figure-html/unnamed-chunk-25-1.png" width="384" /></p>
</div>
</div>
<div id="date" class="section level2">
<h2>Date</h2>
<p>Date values are stored as numbers. But to be properly interpreted as a date object in R, their attribute must be explicitly defined as a <strong>date</strong>. R provides many facilities to convert and manipulate dates and times, but a package called <code>lubridate</code> makes working with dates/times much easier. A separate <a href="Week02c.html">section</a> is dedicated to the creation and manipulation of date objects.</p>
</div>
<div id="na-and-null" class="section level2">
<h2>NA and NULL</h2>
<p>You will find that many data files contain missing or unknown values. It may be tempting to assign these missing or unknown values a <code>0</code> but doing so can lead to many undesirable results when analyzing the data. R has two placeholders for such elements: <code>NA</code> and <code>NULL</code>.</p>
<p>For example, let’s say that we made four measurements where the second measurement was not available but we wanted that missing value to be recorded in our table, we would encode that missing value as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">23</span>, <span class="ot">NA</span>, <span class="fl">1.2</span>, <span class="dv">5</span>)</code></pre></div>
<p><code>NA</code> (Not Available) is a missing value indicator. It suggests that <em>a</em> value should be present but is unknown.</p>
<p>The <code>NULL</code> object also represents missing values but its interpretation is slightly different in that it suggests that the value does not exist or that it’s not measurable.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">23</span>, <span class="ot">NULL</span>, <span class="fl">1.2</span>, <span class="dv">5</span>)</code></pre></div>
<p>The difference between <code>NA</code> and <code>NULL</code> may seem subtle, but their interpretation in some functions can lead to different outcomes. For example, when computing the mean of <code>x</code>, R returns an <code>NA</code> value:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(x)</code></pre></div>
<pre><code>[1] NA</code></pre>
<p>This serves as a check to remind the user that one of the elements is missing. This can be overcome by setting the <code>na.rm</code> parameter to <code>TRUE</code> as in <code>mean(x, na.rm=T)</code> in which case R ignores the missing value.</p>
<p>A <code>NULL</code> object, on the other hand, is treated differently. Since <code>NULL</code> implies that a value <em>should not</em> be present, R no longer feels the need to treat such element as questionable and allows the mean value to be computed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(y)</code></pre></div>
<pre><code>[1] 9.733333</code></pre>
<p>It’s more common to find data tables with missing elements populated with <code>NA</code>’s than <code>NULL</code>’s so unless you have a specific reason to use <code>NULL</code> as a missing value placeholder, use <code>NA</code> instead.</p>
</div>
</div>
<div id="data-structures" class="section level1">
<h1>Data structures</h1>
<p>A data type defines a single element (e.g. a single number or a single date), but most datasets we work with consist of many elements such as a table of temperature values or a list of survey results. These datasets are stored in R in one of several <em>data structures</em> such as <strong>(atomic) vectors</strong>, <strong>matrices</strong>, <strong>data frames</strong> and <strong>lists</strong>.</p>
<div class="figure">
<img src="img/data_structures.png" />

</div>
<div id="atomic-vectors" class="section level2">
<h2>(Atomic) Vectors</h2>
<p>The <strong>atomic vector</strong> (or vector for short) is the simplest data structure in R which consists of an ordered set of values of the same type (e.g. numeric, character, date, etc…). A vector can be created using the <em>combine</em> function <code>c()</code> as in</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">674</span> , <span class="dv">4186</span> , <span class="dv">5308</span> , <span class="dv">5083</span> , <span class="dv">6140</span> , <span class="dv">6381</span>)
x</code></pre></div>
<pre><code>[1]  674 4186 5308 5083 6140 6381</code></pre>
<p>A vector object is an indexable collection of values which allows one to access a specific index number. For example, to access the third element of <code>x</code>, type</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">3</span>]</code></pre></div>
<pre><code>[1] 5308</code></pre>
<p>You can also select a subset of elements by index values using the combine function <code>c()</code>,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">4</span>)]</code></pre></div>
<pre><code>[1]  674 5308 5083</code></pre>
<p>Or, if you are interested in a range of indexed values, use the <code>:</code> operator,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">2</span><span class="op">:</span><span class="dv">4</span>]</code></pre></div>
<pre><code>[1] 4186 5308 5083</code></pre>
<p>You can also assign new values to a specific index. For example, we can replace the second value in vector <code>x</code> with <code>0</code>,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x[<span class="dv">2</span>] &lt;-<span class="st"> </span><span class="dv">0</span>
x</code></pre></div>
<pre><code>[1]  674    0 5308 5083 6140 6381</code></pre>
<p>Note that a vector can store any data type such as characters or strings,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;all&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;olive&quot;</span>)
x</code></pre></div>
<pre><code>[1] &quot;all&quot;   &quot;b&quot;     &quot;olive&quot;</code></pre>
<p>However, a vector can only be of one type. For example, you cannot mix numeric and character types as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>( <span class="fl">1.2</span>, <span class="dv">5</span>, <span class="st">&quot;Rt&quot;</span>, <span class="st">&quot;9-16-2000&quot;</span>)</code></pre></div>
<p>In such a situation, R will convert the element types to the <strong>highest common mode</strong> following the order <strong>NULL &lt; logical &lt; integer &lt; double &lt; character</strong>. In our working example, the elements are coerced to <code>character</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mode</span>(x)</code></pre></div>
<pre><code>[1] &quot;character&quot;</code></pre>
</div>
<div id="matrices-and-arrays" class="section level2">
<h2>Matrices and arrays</h2>
<p>Matrices in R can be thought of as vectors indexed using <em>two</em> indices instead of one. For example, the following line of code creates a 3 by 3 matrix of randomly generated values. The parameters <code>nrow</code> and <code>ncol</code> define the matrix 2D dimension and the function <code>runif()</code> generates the nine random numbers that populate this matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">runif</span>(<span class="dv">9</span>,<span class="dv">0</span>,<span class="dv">10</span>), <span class="dt">nrow =</span> <span class="dv">3</span>, <span class="dt">ncol =</span> <span class="dv">3</span>)
m</code></pre></div>
<pre><code>          [,1]     [,2]      [,3]
[1,] 3.2619298 5.087999 1.4707656
[2,] 7.6767365 3.855925 9.0455366
[3,] 0.7962403 5.457768 0.7772612</code></pre>
<p>If a higher dimension vector is desired, then use the <code>array()</code> function to generate the n-dimensional object. A 3x3x3 array can be created as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="kw">runif</span>(<span class="dv">27</span>,<span class="dv">0</span>,<span class="dv">10</span>), <span class="kw">c</span>(<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>))
m</code></pre></div>
<pre><code>, , 1

           [,1]      [,2]      [,3]
[1,] 4.96707652 6.1121388 2.4113841
[2,] 0.07456467 0.2300082 0.8561746
[3,] 0.43415909 8.0016413 4.2947824

, , 2

          [,1]     [,2]     [,3]
[1,] 2.4664150 1.918241 7.188041
[2,] 8.7000401 5.673075 3.452806
[3,] 0.8046015 9.799181 1.755217

, , 3

          [,1]       [,2]      [,3]
[1,] 1.4170178 0.49012164 5.4418602
[2,] 1.1843084 0.02363908 0.1182934
[3,] 0.4777543 8.30753084 2.9205772</code></pre>
<p>Matrices and arrays can store numeric or character data types, but they cannot store both. This is not to say that you can’t have a matrix of the kind</p>
<pre><code>     [,1] [,2]
[1,] &quot;a&quot;  &quot;2&quot; 
[2,] &quot;b&quot;  &quot;4&quot; </code></pre>
<p>but the value <code>2</code> and <code>4</code> are no longer treated as numeric values but as character values instead.</p>
</div>
<div id="data-frames" class="section level2">
<h2>Data frames</h2>
<p>A <strong>data frame</strong> is what comes closest to our perception of a data <em>table</em>. It’s an extension of the matrix object in that, unlike a matrix, a data frame can <em>mix</em> data types across columns (e.g. both numeric and character columns can coexist in a data frame) but data type remains the same across rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Name   &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a1&quot;</span>, <span class="st">&quot;a2&quot;</span>, <span class="st">&quot;b3&quot;</span>)
Value1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">23</span>, <span class="dv">4</span>, <span class="dv">12</span>)
Value2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">45</span>, <span class="dv">5</span>)
dat    &lt;-<span class="st"> </span><span class="kw">data.frame</span>(Name, Value1, Value2)
dat</code></pre></div>
<pre><code>  Name Value1 Value2
1   a1     23      1
2   a2      4     45
3   b3     12      5</code></pre>
<p>To view each column’s mode type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(dat)</code></pre></div>
<pre><code>&#39;data.frame&#39;:   3 obs. of  3 variables:
 $ Name  : Factor w/ 3 levels &quot;a1&quot;,&quot;a2&quot;,&quot;b3&quot;: 1 2 3
 $ Value1: num  23 4 12
 $ Value2: num  1 45 5</code></pre>
<p>You’ll notice that the <code>Value1</code> and <code>Value2</code> columns are stored as <code>numeric</code> (i.e. as doubles) and not as <code>integer</code> even though the numbers do not contain decimal places. R will assume that any number is <code>numeric</code> unless it is followed by <code>L</code> as in <code>Value1 &lt;- c(23L, 4L, 12L)</code></p>
<p>Like a vector, elements of a data frame can be accessed by their index (aka subscripts). The first index represents the row number and the second index represents the column number. For example, to list the second row of the third column, type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat[<span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<pre><code>[1] 45</code></pre>
<p>If you wish to list all rows for columns one through two leave the first index blank:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat[ , <span class="dv">1</span><span class="op">:</span><span class="dv">2</span> ]</code></pre></div>
<pre><code>  Name Value1
1   a1     23
2   a2      4
3   b3     12</code></pre>
<p>or if you wish to list the third row for all columns, leave the second index blank:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat[ <span class="dv">3</span> , ]</code></pre></div>
<pre><code>  Name Value1 Value2
3   b3     12      5</code></pre>
<p>You can also reference columns by their names if you append the <code>$</code> character to the dataframe object name. For example, to list the values in the column named <code>Value2</code>, type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat<span class="op">$</span>Value2</code></pre></div>
<pre><code>[1]  1 45  5</code></pre>
</div>
<div id="lists" class="section level2">
<h2>Lists</h2>
<p>A <strong>list</strong> is an ordered set of components stored in a 1D structure. In fact, it’s another kind of vector called a <strong>recursive vector</strong> where each vector element can be of different data type and <em>structure</em>. This implies that each element of a list can hold complex objects such as matrices, data frames and other list objects too! Think of a list as a single column spreadsheet where each cell stores anything from a number to a three paragraph sentence to a five column table.</p>
<p>A list is constructed using the <code>list()</code> function. For example, the following list consists of 3 components: a two-column data frame (tagged <code>A</code>), a two element logical vector (tagged <code>B</code>) and a three element character vector (tagged <code>D</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">A &lt;-<span class="st"> </span><span class="kw">data.frame</span>(
     <span class="dt">x =</span> <span class="kw">c</span>(<span class="fl">7.3</span>, <span class="fl">29.4</span>, <span class="fl">29.4</span>, <span class="fl">2.9</span>, <span class="fl">12.3</span>, <span class="fl">7.5</span>, <span class="fl">36.0</span>, <span class="fl">4.8</span>, <span class="fl">18.8</span>, <span class="fl">4.2</span>),
     <span class="dt">y =</span> <span class="kw">c</span>(<span class="fl">5.2</span>, <span class="fl">26.6</span>, <span class="fl">31.2</span>, <span class="fl">2.2</span>, <span class="fl">13.8</span>, <span class="fl">7.8</span>, <span class="fl">35.2</span>, <span class="fl">8.6</span>, <span class="fl">20.3</span>, <span class="fl">1.1</span>)
     )
B &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="ot">TRUE</span>, <span class="ot">FALSE</span>)
D &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;apples&quot;</span>, <span class="st">&quot;oranges&quot;</span>, <span class="st">&quot;round&quot;</span>)

lst &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">A =</span> A, <span class="dt">B =</span> B, <span class="dt">D =</span> D)</code></pre></div>
<p>You can view each component’s structure using the <code>str()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(lst)</code></pre></div>
<pre><code>List of 3
 $ A:&#39;data.frame&#39;:  10 obs. of  2 variables:
  ..$ x: num [1:10] 7.3 29.4 29.4 2.9 12.3 7.5 36 4.8 18.8 4.2
  ..$ y: num [1:10] 5.2 26.6 31.2 2.2 13.8 7.8 35.2 8.6 20.3 1.1
 $ B: logi [1:2] TRUE FALSE
 $ D: chr [1:3] &quot;apples&quot; &quot;oranges&quot; &quot;round&quot;</code></pre>
<p>Each component of a list can be extracted using the <code>$</code> symbol followed by that component’s <strong>tag</strong> name (the name that was assigned to each component when we constructed the list object). For example, to access component <code>A</code> from list <code>lst</code>, type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lst<span class="op">$</span>A</code></pre></div>
<pre><code>      x    y
1   7.3  5.2
2  29.4 26.6
3  29.4 31.2
4   2.9  2.2
5  12.3 13.8
6   7.5  7.8
7  36.0 35.2
8   4.8  8.6
9  18.8 20.3
10  4.2  1.1</code></pre>
<p>You can also access that same component using its <em>numerical index</em>. Since <code>A</code> is the first component in <code>lst</code>, its numerical index is <code>1</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lst[[<span class="dv">1</span>]]</code></pre></div>
<pre><code>      x    y
1   7.3  5.2
2  29.4 26.6
3  29.4 31.2
4   2.9  2.2
5  12.3 13.8
6   7.5  7.8
7  36.0 35.2
8   4.8  8.6
9  18.8 20.3
10  4.2  1.1</code></pre>
<p>Note that we are using <strong>double brackets</strong> to extract <code>A</code>. In doing so, we are extracting <code>A</code> in its <em>native data format</em> (a data frame in this example). Had we used single brackets, <code>A</code> would have been extracted as a <em>list</em> regardless of its native format. The following compares the different data structure outputs between single and double bracketed indices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(lst[[<span class="dv">1</span>]])</code></pre></div>
<pre><code>[1] &quot;data.frame&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(lst[<span class="dv">1</span>])</code></pre></div>
<pre><code>[1] &quot;list&quot;</code></pre>
<p>To list the tag names for each component in a list use the <code>names()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(lst)</code></pre></div>
<pre><code>[1] &quot;A&quot; &quot;B&quot; &quot;D&quot;</code></pre>
<p>Note that lists do not require tag names for their components. For example, we could have created a list as follows (note the omission of <code>A=</code>, <code>B=</code>, etc…):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lst.notags &lt;-<span class="st"> </span><span class="kw">list</span>(A, B, D)</code></pre></div>
<p>Listing its contents displays bracketed indices instead of tag names.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">lst.notags</code></pre></div>
<pre><code>[[1]]
      x    y
1   7.3  5.2
2  29.4 26.6
3  29.4 31.2
4   2.9  2.2
5  12.3 13.8
6   7.5  7.8
7  36.0 35.2
8   4.8  8.6
9  18.8 20.3
10  4.2  1.1

[[2]]
[1]  TRUE FALSE

[[3]]
[1] &quot;apples&quot;  &quot;oranges&quot; &quot;round&quot;  </code></pre>
<p>When lists do not have tags, the <code>names()</code> function will return <code>NULL</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(lst.notags)</code></pre></div>
<pre><code>NULL</code></pre>
<p>It’s usually good practice to assign tags to list components as these can provide meaningful descriptions of each element.</p>
<p>You’ll find that many functions in R return list objects such as the linear regression model function <code>lm</code>. For example, run a regression analysis for vector elements <code>x</code> and <code>y</code> (in data frame <code>A</code>) and save the output of the regression analysis to an object called <code>M</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M &lt;-<span class="st"> </span><span class="kw">lm</span>( y <span class="op">~</span><span class="st"> </span>x, A)</code></pre></div>
<p>Now let’s verify <code>M</code>’s data structure:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(M)</code></pre></div>
<pre><code>[1] &quot;list&quot;</code></pre>
<p>The contents of the regression model object <code>M</code> consists of 12 components which include various diagnostic statistics, regression coefficients, and residuals. Let’s extract each component’s tag (i.e. element name):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(M)</code></pre></div>
<pre><code> [1] &quot;coefficients&quot;  &quot;residuals&quot;     &quot;effects&quot;       &quot;rank&quot;          &quot;fitted.values&quot; &quot;assign&quot;        &quot;qr&quot;           
 [8] &quot;df.residual&quot;   &quot;xlevels&quot;       &quot;call&quot;          &quot;terms&quot;         &quot;model&quot;        </code></pre>
<p>Fortunately, the regression function assigns descriptive tag names to each of its components making it easier to figure out what most of these components represent. For example, it’s clear that the <code>residuals</code> tag stores the residual values from the regression model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M<span class="op">$</span>residuals</code></pre></div>
<pre><code>         1          2          3          4          5          6          7          8          9         10 
-2.1119291 -2.6122265  1.9877735 -0.7516888  1.5332525  0.2898782 -0.5525869  3.7654802  1.5919885 -3.1399416 </code></pre>
<p>The list <code>M</code> is more complex than the simple list <code>lst</code> we created earlier. In addition to having more components, it stores a <em>wider range</em> of data types and structures. For example, element <code>qr</code> is itself a list of five elements!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str</span>(M<span class="op">$</span>qr)</code></pre></div>
<pre><code>List of 5
 $ qr   : num [1:10, 1:2] -3.162 0.316 0.316 0.316 0.316 ...
  ..- attr(*, &quot;dimnames&quot;)=List of 2
  .. ..$ : chr [1:10] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
  .. ..$ : chr [1:2] &quot;(Intercept)&quot; &quot;x&quot;
  ..- attr(*, &quot;assign&quot;)= int [1:2] 0 1
 $ qraux: num [1:2] 1.32 1.44
 $ pivot: int [1:2] 1 2
 $ tol  : num 0.0000001
 $ rank : int 2
 - attr(*, &quot;class&quot;)= chr &quot;qr&quot;</code></pre>
<p>So if we want to access the element <code>rank</code> in the component <code>qr</code> of list <code>M</code>, we can type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M<span class="op">$</span>qr<span class="op">$</span>rank</code></pre></div>
<pre><code>[1] 2</code></pre>
<p>If we want to access <code>rank</code> using indices instead, and noting that <code>qr</code> is the 7<sup>th</sup> component in list <code>M</code> and that <code>rank</code> is the 5th element in list <code>qr</code> we type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M[[<span class="dv">7</span>]][[<span class="dv">5</span>]]</code></pre></div>
<pre><code>[1] 2</code></pre>
<p>This should illustrate the value in assigning <em>tags</em> to list elements; not only do the double brackets clutter the expression, but finding the element numbers can be daunting in a complex list structure.</p>
</div>
</div>
<div id="coercing-data-from-one-type-to-another" class="section level1">
<h1>Coercing data from one type to another</h1>
<p>Data can be coerced from one type to another. For example, to coerce the following vector object from character to numeric, use the <code>as.numeric()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y   &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;23.8&quot;</span>, <span class="st">&quot;6&quot;</span>, <span class="st">&quot;100.01&quot;</span>,<span class="st">&quot;6&quot;</span>)
y.c &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(y)
y.c</code></pre></div>
<pre><code>[1]  23.80   6.00 100.01   6.00</code></pre>
<p>The <code>as.numeric</code> function forces the vector to a double (you could have also used the <code>as.double</code> function). If you convert <code>y</code> to an integer, R will remove all values past the decimal point.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.integer</span>(y)</code></pre></div>
<pre><code>[1]  23   6 100   6</code></pre>
<p>To convert a number to a character use <code>as.character()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">numchar &lt;-<span class="st"> </span><span class="kw">as.character</span>(y.c)
numchar</code></pre></div>
<pre><code>[1] &quot;23.8&quot;   &quot;6&quot;      &quot;100.01&quot; &quot;6&quot;     </code></pre>
<p>You can also coerce a number or character to a factor.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">numfac &lt;-<span class="st"> </span><span class="kw">as.factor</span>(y)
numfac</code></pre></div>
<pre><code>[1] 23.8   6      100.01 6     
Levels: 100.01 23.8 6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">charfac &lt;-<span class="st"> </span><span class="kw">as.factor</span>(y.c)
charfac</code></pre></div>
<pre><code>[1] 23.8   6      100.01 6     
Levels: 6 23.8 100.01</code></pre>
<p>It’s not uncommon for R’s file reading functions to create factors from character variables (columns). If you need to coerce a factor back to a character use the <code>as.character()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">char &lt;-<span class="st"> </span><span class="kw">as.character</span>(charfac)
char</code></pre></div>
<pre><code>[1] &quot;23.8&quot;   &quot;6&quot;      &quot;100.01&quot; &quot;6&quot;     </code></pre>
<div id="factors_xtr" class="section level2">
<h2>A word of caution when converting from factors</h2>
<p>Numbers stored as factors can also be coerced back to numbers, but be careful, the following will not produce the expected output:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">num &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(numfac)
num</code></pre></div>
<pre><code>[1] 2 3 1 3</code></pre>
<p>The output does not look like a numeric representation of the original elements in <code>numfac</code>. Instead it lists integers that <strong>point</strong> to a set of unique values called <strong>levels</strong> that are stored in the vector’s attributes. To see the <em>unique</em> levels in our factor <code>numfac</code>, type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(numfac)</code></pre></div>
<pre><code>[1] &quot;100.01&quot; &quot;23.8&quot;   &quot;6&quot;     </code></pre>
<p>There are three unique values in our vector. The order in which the levels appear in the above output represents the ordered <em>pointer</em> values. So pointer <code>1</code> points to level <code>100.01</code>, pointer <code>2</code> points to level <code>23.8</code>, and pointer <code>3</code> points to level <code>6</code>. So our earlier attempt at converting the factor to a number ended up outputting the pointer values instead.</p>
<div class="figure">
<img src="img/levels.png" />

</div>
<p>So, to extract the actual values (and not the pointers), you must first convert the factor to character before converting to a numeric vector.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">num &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(<span class="kw">as.character</span>(numfac))
num</code></pre></div>
<pre><code>[1]  23.80   6.00 100.01   6.00</code></pre>
<p>There are many coercion functions in R, a summary of some the most common ones we’ll be using in this course follows:</p>
<table style="width:78%;">
<colgroup>
<col width="41%" />
<col width="36%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>as.character()</p></td>
<td><p>Convert to character</p></td>
</tr>
<tr class="even">
<td><p>as.numeric() or as.double()</p></td>
<td><p>Convert to double</p></td>
</tr>
<tr class="odd">
<td><p>as.integer()</p></td>
<td><p>Convert to integer</p></td>
</tr>
<tr class="even">
<td><p>as.factor()</p></td>
<td><p>Convert to factor</p></td>
</tr>
<tr class="odd">
<td><p>as.logical()</p></td>
<td><p>Convert to a Boolean</p></td>
</tr>
</tbody>
</table>
</div>
</div>


<div class="footer">
<hr/>
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a>  Manny Gimond (2018)
</br>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
