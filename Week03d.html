<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Working with string objects</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; } /* Keyword */
code > span.ch { color: #008080; } /* Char */
code > span.st { color: #008080; } /* String */
code > span.co { color: #008000; } /* Comment */
code > span.ot { color: #ff4000; } /* Other */
code > span.al { color: #ff0000; } /* Alert */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #008000; font-weight: bold; } /* Warning */
code > span.cn { } /* Constant */
code > span.sc { color: #008080; } /* SpecialChar */
code > span.vs { color: #008080; } /* VerbatimString */
code > span.ss { color: #008080; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #0000ff; } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ff4000; } /* Preprocessor */
code > span.do { color: #008000; } /* Documentation */
code > span.an { color: #008000; } /* Annotation */
code > span.cv { color: #008000; } /* CommentVar */
code > span.at { } /* Attribute */
code > span.in { color: #008000; } /* Information */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' || rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="libs\style.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<div class="container-fluid main-container">

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->



<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
  padding-left: 25px;
  text-indent: 0;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>

<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">
    <span class="fa fa-home"></span>
     
    
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Data Manipulation
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 02</li>
    <li>
      <a href="Week02a.html">Data types</a>
    </li>
    <li>
      <a href="Week02b.html">Reading and writing data files</a>
    </li>
    <li>
      <a href="Week02c.html">Working with date objects</a>
    </li>
    <li>
      <a href="Week02d.html">Exploring and cleaning dataframes using base functions</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 03</li>
    <li>
      <a href="Week03a.html">Manipulating dataframes with dplyr</a>
    </li>
    <li>
      <a href="Week03d.html">Working with string objects</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 04</li>
    <li>
      <a href="Week03ab_groupby.html">Grouping and summarizing tables</a>
    </li>
    <li>
      <a href="Week03b.html">Tidying/reshaping tables using tidyr</a>
    </li>
    <li>
      <a href="Week03c.html">Joining data tables</a>
    </li>
    <li>
      <a href="Week03ab_examples.html">Example of data manipulation workflows</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Plots
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 05</li>
    <li>
      <a href="Week04a.html">The base plotting environment</a>
    </li>
    <li>
      <a href="Week04b.html">The lattice plotting environment</a>
    </li>
    <li>
      <a href="Week04c.html">The ggplot plotting environment</a>
    </li>
    <li>
      <a href="Week04d.html">Manipulating colors in R</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Univariate
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 06</li>
    <li>
      <a href="Week05a.html">Visualizing univariate data</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 07</li>
    <li>
      <a href="Week05b.html">Comparing univariate data distributions</a>
    </li>
    <li>
      <a href="Week06a.html">Theoretical Q-Q plot</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 08</li>
    <li>
      <a href="Week07a.html">Fits and residuals</a>
    </li>
    <li>
      <a href="Week07b.html">Spread-location plot</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 09</li>
    <li>
      <a href="Week08a.html">Re-expressing data</a>
    </li>
    <li>
      <a href="Week08b.html">Letter value summaries</a>
    </li>
    <li>
      <a href="Week08c.html">The Two R’s of EDA</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Bivariate
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 10</li>
    <li>
      <a href="Week09a.html">Bivariate analysis</a>
    </li>
    <li>
      <a href="Week09b.html">Resistant lines</a>
    </li>
    <li class="divider"></li>
    <li class="dropdown-header">Week 11</li>
    <li>
      <a href="Week10a.html">The third R of EDA: Residuals</a>
    </li>
    <li>
      <a href="Week10b.html">Detecting discontinuities in the data</a>
    </li>
    <li>
      <a href="http://mgimond.github.io/Stats-in-R/regression.html">Details of the OLS regression method (optional reading)</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Two-way tables
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Week 12</li>
    <li>
      <a href="Week11a.html">Median polish/Mean polish</a>
    </li>
    <li>
      <a href="http://mgimond.github.io/Stats-in-R/ANOVA.html">Details of an ANOVA (optional reading)</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Misc
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="Misc01.html">R markdown documents</a>
    </li>
    <li class="dropdown-header">Week 13</li>
    <li>
      <a href="Week12a.html">Creating maps in R</a>
    </li>
    <li class="dropdown-header">Connecting to relational databases</li>
  </ul>
</li>
<li>
  <a href="Data.html">Datasets</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans%7CSource+Code+Pro" rel="stylesheet">

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Working with string objects</h1>

</div>


<div style="color:#ff7535; background-color:#fff0ee ;   border-left-style: solid">
<p>This tutorial makes use of the following R package(s): <strong><code>stringr</code></strong></p>
</div>
<p>Numbers and dates are not the only variable types we might be interested in exploring. We often find ourselves having to manipulate character (text) objects as well. In the programming environment, such queries are often referred to as <strong>string</strong> searches. String queries may involve assessing if a variable matches or contains an exact set of characters; it can also involve extracting a certain set of characters given some pattern. R has a very capable set of string operations built into its environment however, many find it difficult to master. A package that will be used in this tutorial that simplifies this task is called <code>stringr</code>. A write-up of its capabilities can be found <a href="http://journal.r-project.org/archive/2010-2/RJournal_2010-2_Wickham.pdf">here</a>.</p>
<div id="finding-patterns-in-a-string" class="section level1">
<h1>Finding patterns in a string</h1>
<div id="checking-for-an-exact-string-match" class="section level2">
<h2>Checking for an exact string match</h2>
<p>This is the simplest string operation one can perform. It involves assessing if a variable is equal (or not) to a complete text string.</p>
<p>We’ve already seen how the conditional statements can be used to check whether a variable is equal to, less than or greater than a number. We can use conditional statements to evaluate if a variable matches an exact string. For example, the following chunk of code returns <code>TRUE</code> since the strings match exactly.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> &quot;Abc def&quot;</span>
a <span class="op">==</span><span class="st"> &quot;Abc def&quot;</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>However, note that <strong>R differentiates cases</strong> so that the following query, returns <code>FALSE</code> since the first character does not match in case (i.e. upper case <code>A</code> vs. lower case <code>a</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a <span class="op">==</span><span class="st"> &quot;abc def&quot;</span></code></pre></div>
<pre><code>[1] FALSE</code></pre>
<div id="how-to-ignore-case-sensitivity" class="section level3">
<h3>How to ignore case sensitivity?</h3>
<p>If you want R to ignore cases in any string operations, simply force all variables to a lower case and define the pattern being compared against in lower case. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tolower</span>(a) <span class="op">==</span><span class="st"> &quot;abc def&quot;</span></code></pre></div>
<pre><code>[1] TRUE</code></pre>
</div>
</div>
<div id="checking-for-a-partial-match" class="section level2">
<h2>Checking for a partial match</h2>
<div id="matching-anywhere-in-the-string" class="section level3">
<h3>Matching anywhere in the string</h3>
<p>To check if object <code>a</code> has the pattern <code>&quot;c d&quot;</code> (note the space in between the letters) anywhere in its string, use <code>stringr</code>’s <code>str_detect</code> function as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(stringr)
<span class="kw">str_detect</span>(a, <span class="st">&quot;c d&quot;</span>)</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>The following example compares the string to <code>&quot;cd&quot;</code> (note the omission of the space):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_detect</span>(a, <span class="st">&quot;cd&quot;</span>)</code></pre></div>
<pre><code>[1] FALSE</code></pre>
</div>
<div id="matching-the-begining-of-the-string" class="section level3">
<h3>Matching the begining of the string</h3>
<p>To check if object <code>a</code> <em>starts</em> with the pattern <code>&quot;c d&quot;</code> add the carat character <code>^</code> in front of the pattern as in:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_detect</span>(a, <span class="st">&quot;^c d&quot;</span>)</code></pre></div>
<pre><code>[1] FALSE</code></pre>
</div>
<div id="matching-the-end-of-the-sring" class="section level3">
<h3>Matching the end of the sring</h3>
<p>To check if object <code>a</code> <em>ends</em> with the pattern <code>&quot;Abc&quot;</code> add the dollar character <code>$</code> to the end of the pattern as in:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_detect</span>(a, <span class="st">&quot;Abc$&quot;</span>)</code></pre></div>
<pre><code>[1] FALSE</code></pre>
</div>
</div>
<div id="locating-the-position-of-a-pattern-in-a-string" class="section level2">
<h2>Locating the position of a pattern in a string</h2>
<p>If you want to find <em>where</em> a particular pattern lies in a string, use the <code>str_locate</code> function. For example, to find where the pattern <code>&quot;c d&quot;</code> occurs in object <code>a</code> type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_locate</span>(a, <span class="st">&quot;c d&quot;</span>)</code></pre></div>
<pre><code>     start end
[1,]     3   5</code></pre>
<p>The function returns two values: the position in the string where the pattern <strong>starts</strong> (e.g. position 3) and the position where the pattern ends (e.g. position 5 )</p>
<p>Note that if the pattern is not found, <code>str_locate</code> returns <code>NA</code>’s:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_locate</span>(a, <span class="st">&quot;cd&quot;</span>)</code></pre></div>
<pre><code>     start end
[1,]    NA  NA</code></pre>
<p>Note too that the <code>str_locate</code> function only returns the position of the first occurrence. For example, the following chunk will only return the start/end positions of the first occurrence of <code>Ab</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">b &lt;-<span class="st"> &quot;Abc def Abg&quot;</span>
<span class="kw">str_locate</span>(b, <span class="st">&quot;Ab&quot;</span>)</code></pre></div>
<pre><code>     start end
[1,]     1   2</code></pre>
<p>To find <em>all</em> occurrences, use the <code>str_locate_all()</code> function as in:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_locate_all</span>(b,<span class="st">&quot;Ab&quot;</span>)</code></pre></div>
<pre><code>[[1]]
     start end
[1,]     1   2
[2,]     9  10</code></pre>
<p>The function returns a <code>list</code> object. To extract the position values into a dateframe, simply wrap the function in a call to <code>as.data.frame</code>, for example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">str.pos &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(<span class="kw">str_locate_all</span>(b,<span class="st">&quot;Ab&quot;</span>))
str.pos</code></pre></div>
<pre><code>  start end
1     1   2
2     9  10</code></pre>
<p>The reason <code>str_locate_all</code> returns a list and not a matrix or a data frame can be understood in the following example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Create a 5 element string vector</span>
d &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Abc&quot;</span>, <span class="st">&quot;Def &quot;</span>, <span class="st">&quot;Abc Def Ab&quot;</span>, <span class="st">&quot; bc &quot;</span>, <span class="st">&quot;ef &quot;</span>)

<span class="co"># Search for all instances of &quot;Ab&quot;</span>
<span class="kw">str_locate_all</span>(d,<span class="st">&quot;Ab&quot;</span>)</code></pre></div>
<pre><code>[[1]]
     start end
[1,]     1   2

[[2]]
     start end

[[3]]
     start end
[1,]     1   2
[2,]     9  10

[[4]]
     start end

[[5]]
     start end</code></pre>
<p>Here, <code>d</code> is a five element string vector (so far we’ve worked with single element vectors). The <code>str_locate_all</code> function returns a result for <em>each</em> element of that vector, and since patterns can be found multiple times in a same vector element, the output can only be conveniently stored in a list.</p>
</div>
<div id="finding-the-length-of-a-string" class="section level2">
<h2>Finding the length of a string</h2>
<p>A natural extension to finding the positions of patterns in a text is to find the string’s total length. This can be accomplished with the <code>str_length()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_length</span>(b)</code></pre></div>
<pre><code>[1] 11</code></pre>
<p>For a multi-element vector, the output looks like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_length</span>(d)</code></pre></div>
<pre><code>[1]  3  4 10  4  3</code></pre>
</div>
<div id="finding-a-patterns-frequency" class="section level2">
<h2>Finding a pattern’s frequency</h2>
<p>To find out how often the pattern <code>Ab</code> occurs in each element of object <code>d</code>, use the <code>str_count()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_count</span>(d, <span class="st">&quot;Ab&quot;</span>)</code></pre></div>
<pre><code>[1] 1 0 2 0 0</code></pre>
</div>
</div>
<div id="modifying-strings" class="section level1">
<h1>Modifying strings</h1>
<div id="padding-numbers-with-leading-zeros" class="section level2">
<h2>Padding numbers with leading zeros</h2>
<p>The <code>str_pad()</code> function can be used to pad numbers with leading zeros. Note that in doing so, you are creating a character object from a numeric object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">12</span>, <span class="dv">2</span>, <span class="dv">503</span>, <span class="dv">20</span>, <span class="dv">0</span>)
<span class="kw">str_pad</span>(e, <span class="dt">width=</span><span class="dv">3</span>, <span class="dt">side=</span><span class="st">&quot;left&quot;</span>, <span class="dt">pad =</span> <span class="st">&quot;0&quot;</span> )</code></pre></div>
<pre><code>[1] &quot;012&quot; &quot;002&quot; &quot;503&quot; &quot;020&quot; &quot;000&quot;</code></pre>
</div>
<div id="appending-text-to-strings" class="section level2">
<h2>Appending text to strings</h2>
<p>You can append strings with custom text using the <code>str_c()</code> functions. For example, to add the string length at the end of each vector element in <code>b</code> type,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_c</span>(d, <span class="st">&quot; has &quot;</span>, <span class="kw">str_length</span>(d), <span class="st">&quot; characters&quot;</span> )</code></pre></div>
<pre><code>[1] &quot;Abc has 3 characters&quot;         &quot;Def  has 4 characters&quot;        &quot;Abc Def Ab has 10 characters&quot;
[4] &quot; bc  has 4 characters&quot;        &quot;ef  has 3 characters&quot;        </code></pre>
</div>
<div id="removing-white-spaces" class="section level2">
<h2>Removing white spaces</h2>
<p>You can remove leading or ending (or both) white spaces from a string. For example, to remove leading white spaces from object <code>d</code> type,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d.left.trim &lt;-<span class="st"> </span><span class="kw">str_trim</span>(d, <span class="dt">side=</span><span class="st">&quot;left&quot;</span>)</code></pre></div>
<p>Now let’s compare the original to the left-trimmed version:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_length</span>(d)</code></pre></div>
<pre><code>[1]  3  4 10  4  3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_length</span>(d.left.trim)</code></pre></div>
<pre><code>[1]  3  4 10  3  3</code></pre>
<p>To remove trailing spaces set <code>side = &quot;right&quot;</code> and to remove both leading and trailing spaces set <code>side = &quot;both&quot;</code>.</p>
</div>
<div id="replacing-elements-of-a-string" class="section level2">
<h2>Replacing elements of a string</h2>
<p>To replace all instances of a specified set of characters in a string with another set of characters, use the <code>str_replace_all()</code> function. For example, to replace all <em>spaces</em> in object <code>b</code> with <em>dashes</em>, type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_replace_all</span>(b, <span class="st">&quot; &quot;</span>, <span class="st">&quot;-&quot;</span>)</code></pre></div>
<pre><code>[1] &quot;Abc-def-Abg&quot;</code></pre>
</div>
</div>
<div id="extracting-parts-of-a-string" class="section level1">
<h1>Extracting parts of a string</h1>
<div id="extracting-elements-of-a-string-given-start-and-end-positions" class="section level2">
<h2>Extracting elements of a string given start and end positions</h2>
<p>To find the character elements of a vector at a given position of a given string, use the <code>str_sub()</code> function. For example, to find the characters between positions two and five (inclusive) type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_sub</span>(b, <span class="dt">start=</span><span class="dv">2</span>, <span class="dt">end=</span><span class="dv">5</span>)</code></pre></div>
<pre><code>[1] &quot;bc d&quot;</code></pre>
<p>If you don’t specify a <code>start</code> position, then all characters up to and including the <code>end</code> position will be returned. Likewise, if the <code>end</code> position is not specified then all characters from the <code>start</code> position to the end of the string will be returned.</p>
</div>
<div id="splitting-a-string-by-a-character" class="section level2">
<h2>Splitting a string by a character</h2>
<p>If you want to break a string up into individual components based on a character delimiter, use the <code>str_split()</code> function. For example, to split the following string into separate elements by comma, type the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> &quot;Year:2000, Month:Jan, Day:23&quot;</span>
<span class="kw">str_split</span>(g, <span class="st">&quot;,&quot;</span>)</code></pre></div>
<pre><code>[[1]]
[1] &quot;Year:2000&quot;  &quot; Month:Jan&quot; &quot; Day:23&quot;   </code></pre>
<p>The output is a one element list. If object <code>g</code> consists of more than one element, the output will be a list of as many elements as there are <code>g</code> elements.</p>
<p>Depending on your workflow, you may need to convert the <code>str_split</code> output to an atomic vector. For example, if you want to find an element in the above <code>str_split</code> output that matches the string <code>Year:2000</code>, the following will return <code>FALSE</code> and not <code>TRUE</code> as expected:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;Year:2000&quot;</span> <span class="op">%in%</span><span class="st"> </span><span class="kw">str_split</span>(g, <span class="st">&quot;,&quot;</span>)</code></pre></div>
<pre><code>[1] FALSE</code></pre>
<p>The workaround is to convert the right-hand output to a single vector using the <code>unlist</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="st">&quot;Year:2000&quot;</span> <span class="op">%in%</span><span class="st"> </span><span class="kw">unlist</span>(<span class="kw">str_split</span>(g, <span class="st">&quot;,&quot;</span>))</code></pre></div>
<pre><code>[1] TRUE</code></pre>
<p>If you are applying the split function to a column of data from a dataframe, you will want to use the function <code>str_split_fixed</code> instead. This function assumes that the number of components to be extracted via the split will be the same for each vector element. For example, the following vector, <code>T1</code>, has <strong>two</strong> time components that need to be extracted. The separator is a dash, <code>-</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;9:30am-10:45am&quot;</span>, <span class="st">&quot;9:00am- 9:50am&quot;</span>, <span class="st">&quot;1:00pm- 2:15pm&quot;</span>)
T1</code></pre></div>
<pre><code>[1] &quot;9:30am-10:45am&quot; &quot;9:00am- 9:50am&quot; &quot;1:00pm- 2:15pm&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">str_split_fixed</span>(T1, <span class="st">&quot;-&quot;</span>, <span class="dv">2</span>)</code></pre></div>
<pre><code>     [,1]     [,2]     
[1,] &quot;9:30am&quot; &quot;10:45am&quot;
[2,] &quot;9:00am&quot; &quot; 9:50am&quot;
[3,] &quot;1:00pm&quot; &quot; 2:15pm&quot;</code></pre>
<p>The third parameter in the <code>str_split_fixed</code> function is the number of elements to return which also defines the output dimension (here, a three row and two column table). If you want to extract both times to separate vectors, reference the columns by index number:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T1.start &lt;-<span class="st"> </span><span class="kw">str_split_fixed</span>(T1, <span class="st">&quot;-&quot;</span>, <span class="dv">2</span>)[ ,<span class="dv">1</span>]
T1.start</code></pre></div>
<pre><code>[1] &quot;9:30am&quot; &quot;9:00am&quot; &quot;1:00pm&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T1.end   &lt;-<span class="st"> </span><span class="kw">str_split_fixed</span>(T1, <span class="st">&quot;-&quot;</span>, <span class="dv">2</span>)[ ,<span class="dv">2</span>]
T1.end</code></pre></div>
<pre><code>[1] &quot;10:45am&quot; &quot; 9:50am&quot; &quot; 2:15pm&quot;</code></pre>
<p>You will want to use the indexes if you are extracting strings in a data frame. For example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dat &lt;-<span class="st"> </span><span class="kw">data.frame</span>( <span class="dt">Time =</span> <span class="kw">c</span>(<span class="st">&quot;9:30am-10:45am&quot;</span>, <span class="st">&quot;9:00am-9:50am&quot;</span>, <span class="st">&quot;1:00pm-2:15pm&quot;</span>))
dat<span class="op">$</span>Start_time &lt;-<span class="st"> </span><span class="kw">str_split_fixed</span>(dat<span class="op">$</span>Time, <span class="st">&quot;-&quot;</span>, <span class="dv">2</span>)[ , <span class="dv">1</span>]
dat<span class="op">$</span>End_time   &lt;-<span class="st"> </span><span class="kw">str_split_fixed</span>(dat<span class="op">$</span>Time, <span class="st">&quot;-&quot;</span>, <span class="dv">2</span>)[ , <span class="dv">2</span>]
dat</code></pre></div>
<pre><code>            Time Start_time End_time
1 9:30am-10:45am     9:30am  10:45am
2  9:00am-9:50am     9:00am   9:50am
3  1:00pm-2:15pm     1:00pm   2:15pm</code></pre>
</div>
<div id="extracting-parts-of-a-string-that-follow-a-pattern" class="section level2">
<h2>Extracting parts of a string that follow a pattern</h2>
<p>To extract the three letter months from object <code>g</code> (defined in the last example), you can use a combination of <code>stringr</code> functions as in:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">loc &lt;-<span class="st"> </span><span class="kw">str_locate</span>(g, <span class="st">&quot;Month:&quot;</span>)
<span class="kw">str_sub</span>(g, <span class="dt">start =</span> loc[,<span class="st">&quot;end&quot;</span>] <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">end =</span> loc[,<span class="st">&quot;end&quot;</span>]<span class="op">+</span><span class="dv">3</span>)</code></pre></div>
<pre><code>[1] &quot;Jan&quot;</code></pre>
<p>The above chunk of code first identifies the position of the <code>Month:</code> string and passes its output to the object <code>loc</code> (a matrix). It then uses the <code>loc</code>’s <code>end</code> position in the call to <code>str_sub</code> to extract the three characters making up the month abbreviation. The value <code>1</code> is added to the <code>start</code> parameter in <code>str_sub</code> to omit the last character of <code>Month:</code> (recall that the <code>str_locate</code> positions are inclusive).</p>
<p>This can be extend to multi-element vectors as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Note the differences in spaces and string lenghts between the vector</span>
<span class="co"># elements.</span>
gs &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;Year:2000, Month:Jan, Day:23&quot;</span>,
        <span class="st">&quot;Year:345, Month:Mar, Day:30&quot;</span>,
        <span class="st">&quot;Year:1867 , Month:Nov, Day:5&quot;</span>)

loc &lt;-<span class="st"> </span><span class="kw">str_locate</span>(gs, <span class="st">&quot;Month:&quot;</span>)
<span class="kw">str_sub</span>(gs, <span class="dt">start =</span> loc[,<span class="st">&quot;end&quot;</span>] <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">end =</span> loc[,<span class="st">&quot;end&quot;</span>]<span class="op">+</span><span class="dv">3</span>)</code></pre></div>
<pre><code>[1] &quot;Jan&quot; &quot;Mar&quot; &quot;Nov&quot;</code></pre>
<p>Note the non-uniformity in each element’s length and <code>Month:</code> position which requires that we explicitly search for the <code>Month:</code> string position in each element. Had all elements been of equal length and format, we could have simply assigned the position numbers in the call to <code>str_sub</code> function.</p>
</div>
</div>


<div class="footer">
<hr/>
<a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a>  Manny Gimond (2019)
</br>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
